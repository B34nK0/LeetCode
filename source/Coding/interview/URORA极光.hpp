/*
c++11 特性有哪些

1、左值与右值
左值是指表达式结束后依然存在的持久对象
右值是指表达式结束时就不再存在的临时对象

2、通过右值方式得到函数里的变量
a、函数返回的临时对象是右值，可以通过右值引用（T &&）的方式来延长临时右值的生命周期
A GetA() {
	return A();
}

A&& a = GetA();
、
b、通过常量左值引用（接受左值、右值、常量左值和常量右值），必须是常量左值引用
const A& a = GetA();


3、move之后对象在哪里
moove方法将对象的状态或者所有权从给一个对象转移到另一个对象，只是转移，并没有内存拷贝，可理解为将一个左值强制转换为一个右值引用

move跟forward
forward要解决的是在函数模板中，完全按照模板的参数的类型（保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。

4、unique_ptr 与 auto_ptr的区别
unique_ptr是独占型只能指针，不允许其他的智能指针共享其内部的指针，不允许赋值，但支持move转移所有权
虽然同一时间只有一个auto_ptr拥有对象的指针，但其允许复制，会导致另一个auto_ptr指向空指针，造成指针访问异常

5、shared_ptr的实现机制
使用引用计数，每一个shared_ptr拷贝都指向相同的内存，最后一个shared_ptr析构时，内存才会释放

6、shared_ptr循环引用
把循环引用的任何一个成员变量改为weak_ptr

7、虚函数表相关信息
派生类在编译时，会生成一个虚函数表指针和虚函数表，虚函数表记录派生类重载的函数实现地址

内存布局的哪个区
对象指针 A* obj存放在栈上， 指针指向堆上的实例A内存，A实例内存里包含了虚表指针，指针指向只读数据段上的虚函数表，虚函数表记录的是派生类重载实现的函数指针，函数指针指向代码段上的虚函数代码

A重写B类的虚函数，内存有什么变化
A实例内存有虚表指针

8、进程跟线程之间的区别
进程是资源分配的最小单位、线程是CPU调度的最小单位
一个线程只能属于一个进程，一个进程可以有多个线程
进程在执行过程中拥有独立内存单元，而多个线程共享所属进程的内存。
（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。
但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
进程的系统开销（创建、撤销、调度执行）比线程大
进程内的线程具有相同的内存地址，线程间通信简单
进程间独立不影响，线程异常会导致进程异常，进而影响其他线程
进程适用于多核、多机， 线程适用于多核

9、什么场景下使用进程、线程
cpu密集型时使用进程，可以独占cpu进行计算任务
io密集型时可以使用线程

10、进程间通信方式
管道
	命名管道、匿名管道


系统IPC（信号量、信号、消息队列、共享内存）
信号量：主要用于进程同步，多用于配合共享内存，实现进程通信

信号：用于通知接收进程某个事件已经发生

消息队列：是消息的链接表，存放在内核中

共享内存：多个进程操作同一内存，最快的IPC方式，需要采用信号量同步多进程对共享内存的操作

套接字Socket
用于不同主机间通信


11、线程间通信方式
线程间通信主要目的在于线程同步，并不是进行数据交换（数据交互更多体现在临界资源的操作）

锁机制:互斥锁(mutex)、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）

信号量机制

信号

屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。

12、epoll跟IOCP的区别
Epoll 是当事件资源满足时发出可处理通知消息；而 IOCP 则是当事件完成时发出完成通知消息。
epoll是同步非阻塞、iocp是异步非阻塞

13、阻塞\非阻塞,同步\异步分别是在哪些阶段
阻塞\非阻塞主要用于创建IO句柄后，用户是阻塞等待等待数据，还是非阻塞去做其他事情，IO有数据时再通知用户进行读取
异步\同步在于读取数据的动作，同步指读取数据时缓冲区数据没有读取完时一直读取，还是用户去做其他事情，等待全部数据读取完再通知用户读取


14、epoll用到的是水平触发还是边缘触发
et边缘触发：et模式，是当发生事件时进行一次通知，epool_wait获取该次事件后，如果用户不处理完缓冲区数据，使用epoll_wait是不会再获取到事件
所以必须使用非阻塞io，如果使用阻塞io，那么不处理完数据时，阻塞读写会把处理多个文件描述符的任务饿死

lt水平触发：当一个文件句柄准备就绪时，内核会通知用户进行io操作，如果不进行任何操作时，内核还是会继续通知用户关于该句柄的事件

15、水平触发跟边缘触发的优缺点
epoll默认时水平触发，其优点是如果io有数据，会一直通知，保证了数据的完整输出
缺点是只要一有数据，内核就会不断的通知，进行内核态到用户态的切换，占用了大量的内核资源

边缘触发的优点是每次内核只通知一次，大大减少了内核资源的浪费，提高效率
缺点是，不能保证数据的完整性，不能及时取出所有的数据

场景：使用边缘触发时，如果有读事件时，没有把数据读取完，在socket没有新的数据可读时，epoll就不返回了，那需要等到新的数据来时，epoll返回可读事件时才能继续读
使用水平触发时，如果关注写事件时，多次写时都会有epoll的返回，那么会造成内核资源的浪费，一般也不关注写事件

16、accept，socket处于什么状态，在半链接队列还是全链接队列里

环形缓冲区

无锁是怎么实现

cas为什么能实现无锁

cas aba问题

内存模型


*/
/*
mysql

分表

分库分表的方案

聚簇索引跟非聚簇索引的实现


*/

/*
redis 使用了哪些数据类型及场景

redis是独立数据，还是mysql的缓存

redis如何做到数据一致性，mysql更新完成程序崩溃

redis淘汰策略
*/

/*
service mesh

注册中心机制

远程调用，服务不可用

服务不可用是否实现高可用（负载转发）

负载均衡策略有哪些


*/